/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.11
 */
import * as reactQuery from "@tanstack/react-query";
import { useSandboxContext, SandboxContext } from "./sandboxContext";
import type * as Fetcher from "./sandboxFetcher";
import { sandboxFetch } from "./sandboxFetcher";
import type * as Schemas from "./sandboxSchemas";

export type RootGetError = Fetcher.ErrorWrapper<undefined>;

export type RootGetVariables = SandboxContext["fetcherOptions"];

/**
 * Sample description.
 */
export const fetchRootGet = (
  variables: RootGetVariables,
  signal?: AbortSignal,
) =>
  sandboxFetch<void, RootGetError, undefined, {}, {}, {}>({
    url: "/v1",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Sample description.
 */
export const useRootGet = <TData = void,>(
  variables: RootGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, RootGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSandboxContext(options);
  return reactQuery.useQuery<void, RootGetError, TData>({
    queryKey: queryKeyFn({ path: "/v1", operationId: "rootGet", variables }),
    queryFn: ({ signal }) =>
      fetchRootGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type AuthorizationQueryParams = {
  response_type: "token";
  /**
   * The client identifier. We use email as it.
   */
  client_id: string;
  /**
   * The URI to redirect to after authorization.
   *
   * @format uri
   * @default
   */
  redirect_uri?: string;
  /**
   * A list of scopes expressed as a list of space-delimited, case-sensitive strings. default is [general]
   *
   * @default general
   */
  scope?: string[];
  /**
   * RECOMMENDED.  An opaque value used by the client to maintain state between the request and callback.
   *
   * @default
   */
  state?: string;
};

export type AuthorizationError = Fetcher.ErrorWrapper<undefined>;

export type AuthorizationVariables = {
  queryParams: AuthorizationQueryParams;
} & SandboxContext["fetcherOptions"];

/**
 * Authorization Request spec. For detail, see https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.
 */
export const fetchAuthorization = (
  variables: AuthorizationVariables,
  signal?: AbortSignal,
) =>
  sandboxFetch<
    undefined,
    AuthorizationError,
    undefined,
    {},
    AuthorizationQueryParams,
    {}
  >({ url: "/v1/auth/authorization", method: "get", ...variables, signal });

/**
 * Authorization Request spec. For detail, see https://datatracker.ietf.org/doc/html/rfc6749#section-4.2.
 */
export const useAuthorization = <TData = undefined,>(
  variables: AuthorizationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, AuthorizationError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSandboxContext(options);
  return reactQuery.useQuery<undefined, AuthorizationError, TData>({
    queryKey: queryKeyFn({
      path: "/v1/auth/authorization",
      operationId: "authorization",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchAuthorization({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type MeError = Fetcher.ErrorWrapper<undefined>;

export type MeVariables = SandboxContext["fetcherOptions"];

/**
 * Return user info if authed.
 */
export const fetchMe = (variables: MeVariables, signal?: AbortSignal) =>
  sandboxFetch<Schemas.User, MeError, undefined, {}, {}, {}>({
    url: "/v1/auth/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return user info if authed.
 */
export const useMe = <TData = Schemas.User,>(
  variables: MeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, MeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useSandboxContext(options);
  return reactQuery.useQuery<Schemas.User, MeError, TData>({
    queryKey: queryKeyFn({ path: "/v1/auth/me", operationId: "me", variables }),
    queryFn: ({ signal }) =>
      fetchMe({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type LoginQueryParams = {
  /**
   * @format email
   */
  email: string;
  password: string;
};

export type LoginError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type LoginVariables = {
  queryParams: LoginQueryParams;
} & SandboxContext["fetcherOptions"];

/**
 * Login.
 */
export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  sandboxFetch<Schemas.User, LoginError, undefined, {}, LoginQueryParams, {}>({
    url: "/v1/auth/login",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Login.
 */
export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.User, LoginError, LoginVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSandboxContext();
  return reactQuery.useMutation<Schemas.User, LoginError, LoginVariables>({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type RegisterQueryParams = {
  /**
   * @format email
   */
  email: string;
  password: string;
};

export type RegisterError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type RegisterVariables = {
  queryParams: RegisterQueryParams;
} & SandboxContext["fetcherOptions"];

/**
 * Register.
 */
export const fetchRegister = (
  variables: RegisterVariables,
  signal?: AbortSignal,
) =>
  sandboxFetch<void, RegisterError, undefined, {}, RegisterQueryParams, {}>({
    url: "/v1/auth/register",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Register.
 */
export const useRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<void, RegisterError, RegisterVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSandboxContext();
  return reactQuery.useMutation<void, RegisterError, RegisterVariables>({
    mutationFn: (variables: RegisterVariables) =>
      fetchRegister({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LogoutError = Fetcher.ErrorWrapper<undefined>;

export type LogoutVariables = SandboxContext["fetcherOptions"];

/**
 * Logout.
 */
export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  sandboxFetch<undefined, LogoutError, undefined, {}, {}, {}>({
    url: "/v1/auth/logout",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Logout.
 */
export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useSandboxContext();
  return reactQuery.useMutation<undefined, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/v1";
      operationId: "rootGet";
      variables: RootGetVariables;
    }
  | {
      path: "/v1/auth/authorization";
      operationId: "authorization";
      variables: AuthorizationVariables;
    }
  | {
      path: "/v1/auth/me";
      operationId: "me";
      variables: MeVariables;
    };
